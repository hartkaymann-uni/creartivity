#version 440
#define N_USERS 10

struct Particle{
	vec4 pos;
	vec4 vel;
	vec4 color;
	vec4 unique;
	vec4 initialPos;
	vec4 bufferPos;
};

layout(std140, binding=0) buffer particle{
    Particle p[];
};

layout(std140, binding=1) buffer particleBack{
    Particle p2[];
};

layout(std140, binding=3) buffer particleDraw{
    Particle p3[];
};

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

uniform int freeze_particles;
uniform float timeLastFrame;
uniform float elapsedTime;
uniform float max_speed;
uniform float attr_force;
uniform vec3 mouse;
uniform vec3 hands[N_USERS];
uniform int user_count;


// ### Movement
vec3 applyMaxSpeed(vec3 velocity, float limit){
	vec3 dir = normalize(velocity);
	// If current velocity exeeds the max_speed, set it to max_speed
	if(length(velocity)>limit){
		return dir * limit;
	} else {
		return velocity;
	}
}

vec3 calculateAcceleration(vec3 particlePos) {
	vec3 acc = vec3(0.0,0.0,0.0);
	
	vec3 extra = vec3(mouse.x, mouse.y, -100);
	vec3 attrDir = extra - particlePos;

	acc += normalize(attrDir) * attr_force;

	return acc;
}

void calculateMovement(){
	if(freeze_particles == 1) {
		return;
	}

    vec3 acc = calculateAcceleration(p2[gl_GlobalInvocationID.x].pos.xyz);
	p[gl_GlobalInvocationID.x].vel.xyz += acc*timeLastFrame;
	p[gl_GlobalInvocationID.x].vel.xyz *= 0.99;
	p[gl_GlobalInvocationID.x].vel.xyz = applyMaxSpeed(p[gl_GlobalInvocationID.x].vel.xyz, max_speed);
}


// ### Main
void main(){
	//vec3 particle = p2[gl_GlobalInvocationID.x].pos.xyz;
	calculateMovement();


	// vec4 testColor = vec4(0,0,0,1);
	// //testColor.r = 0.1 * user_count;
	// testColor.rgb = hands[0].xyz;
    // p[gl_GlobalInvocationID.x].color = testColor;
	// int index = int(p[gl_GlobalInvocationID.x].unique.y);
	// p3[index].color = p[gl_GlobalInvocationID.x].color;
}


float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

// void calculateAttraction(vec3 particle){
// 	int radius = 100;
// 	vec3 modAttractor = vec3(0.0, 0.0, 1000);
// 	for(int i = 0; i < N_USERS; i++) {
// 		vec2 hand = hands[i].xy;
// 		if(hand != vec2(0.0)) {
// 			float dist = distance(particle.xy, hand);
// 			float influence = map(dist, radius, 0.0, 0.0, 1.0);
// 			//modAttractor.xy += (hand - particle.xy) * influence;
// 		}
// 	}

// 	// Mouse also interacts
// 	float dist = distance(particle.xy, attractor.xy);
// 	float influence = map(dist, radius, 0.0, 0.0, 1.0);
// 	modAttractor.xy += (attractor.xy - particle.xy) * influence;
	
// 	modAttractor = vec3(hands[0].x, hands[0].y, 1000);
// }