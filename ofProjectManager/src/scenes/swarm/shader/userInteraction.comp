#version 440
#define N_USERS 10

struct Particle{
	vec4 pos;
	vec4 vel;
	vec4 color;
	vec4 unique;
	vec4 initialPos;
	vec4 bufferPos;
};

layout(std140, binding=0) buffer particle{
    Particle p[];
};

layout(std140, binding=1) buffer particleBack{
    Particle p2[];
};

layout(std140, binding=3) buffer particleDraw{
    Particle p3[];
};

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

uniform int freeze_particles;
uniform float timeLastFrame;
uniform float elapsedTime;
uniform float max_speed;
uniform float attr_force;
uniform vec3 hands[N_USERS];
uniform int hand_count;


// ### Movement
vec3 applyMaxSpeed(vec3 velocity, float limit){
	vec3 dir = normalize(velocity);
	// If current velocity exeeds the max_speed, set it to max_speed
	if(length(velocity)>limit){
		return dir * limit;
	} else {
		return velocity;
	}
}

vec3 calculateAcceleration(vec3 particlePos) {
	vec3 acc = vec3(0.0,0.0,0.0);

	uint index = gl_GlobalInvocationID.x % (hand_count);

  	vec3 handPos = vec3(hands[index].x, hands[index].y, 100);
	vec3 difference = handPos - particlePos;
	acc += normalize(difference) * attr_force;
	

	return acc;
}

void calculateMovement(){
	if(freeze_particles == 1) {
		return;
	}

    vec3 acc = calculateAcceleration(p2[gl_GlobalInvocationID.x].pos.xyz);
	p[gl_GlobalInvocationID.x].vel.xyz += acc*timeLastFrame;
	p[gl_GlobalInvocationID.x].vel.xyz *= 0.99;
	p[gl_GlobalInvocationID.x].vel.xyz = applyMaxSpeed(p[gl_GlobalInvocationID.x].vel.xyz, max_speed);
}

// ### Main
void main(){
	if(hand_count == 0) return;
	calculateMovement();
}